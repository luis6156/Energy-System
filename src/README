Stage 1 - Energy System - Copyright Micu Florian-Luis 321CA

In order to explain my implementation of this homework, I will discuss in
detail every package.

src/entities:
This package stores all entity related classes. An entity is created using the
factory (implemented with singleton). All types of entities are stored as
enums. This far, the entities known are Consumer and Distributor. A bond
between two entities can be created using the Contract class.

Entity (Abstract Class)
An entity object has an id, a budget and bankruptcy flag. The method associated
with this object are used for creating contracts, removing contracts and
updating its budget. All of the attributes and methods were created so that
if a new type of entity is added it can easily inherit all of the common
properties needed for the game.

Consumer (Inherits from Entity):
This class has an extra attribute "monthlyIncome" that is added monthly to the
budget in the "advanceBudget" method. The "advanceLease" method is used to
subtract from the budget the price of the contract associated with this class.
If the contract cannot be paid, I check if there was a penalty already added.
If the condition is true, then I file the consumer for bankruptcy and terminate
the contract, otherwise I tell the contract to add a penalty to the price. The
best contract is automatically sent to the consumer by the class "GameRules".

Distributor (Inherits from Entity):
A distributor has "infrastructureCost", "productionCost" and "contractLength"
in addition to the other attributes. The main task of the distributor is to
compute the price of the contract each month using the two costs and the
number of current clients, thus I have two extra attributes: "contractCost" and
a list of contracts. As opposed to the other entity, this one advances his
budget by subtracting from the budget the monthly costs and advances its lease
by adding to the budget the price of the contracts that have been paid this
month. If after all of the updates the budget is negative, I file the
distributor for bankruptcy and I terminate all of its contracts. If the class
"GameRules" determines that this distributor has the best price, I will add
a new contract to the list of contracts.

Contract:
I created this class in order to retain the relevant information from a bond
of two entities: the contract's price, the contract's penalty, the remaining
months, the IDs of both parties, a flag that indicates the contract has been
fully paid and a flag that indicates that the contract has been canceled. A
contract can be canceled by both parties when one of them goes bankrupt. This
class has an "advanceContract" method that decrements the number of months
and that applies/deducts a penalty based on weather or not the contractee paid
(a boolean is used as parameter). The price of the contract is always updated
to contain the penalty (penalty is 0 when there is no debt to maintain the
correct price).
Note: I used two methods for getting the price: one that returns the price +
penalty (for the game) and one that returns only the price (for output) as
for the Test 15 I would print the wrong contract price with the first getter.
In addition, I tried to make this accurate to real life, that is why I store
both of the parties IDs, even though its not necessary it helps me make the
class more general.

src/game:
In this package I store the game logic as well as the game updates and
entities.

GameRules:
This class has methods that act as steps in order to progress the game
properly:

"processChanges": updates the distributor's costs and/or adds new consumers to
                    the game
"createContracts": used to tell all distributor's to compute the price of this
                    month's contracts
"purgePaidContracts": removes all paid contracts from all entities
"signContracts": takes the distributor with the least expensive contract and
                    creates a contract between him and the consumers that
                    do not have a contract
"updatePlayersBudgets": advances all entities budgets and then advances their
                    leases as well as checking for bankruptcy
"purgeCanceledContracts": removes all canceled contracts from all entities
                    (one party went bankrupt in the process)
"purgeBrokePlayers": removes all broke entities from the active players
                    and adds them to bankrupt players

Game:
This class advances the game to the end and prepares the entities for output.

The "startGame" method starts with a round zero in which I create contracts,
assign contracts and update the budgets and then I advance the game by calling
the GameRules' methods in the exact above order.

The "finishGame" method appends the list of active players with the list of
bankrupt players and sorts them by ID, in order to print the entities.

src/fileio:
The Reader class is used to get input from a file and create entities using
the Factory as well as to determine the number of turns and to read the
monthly updates. After the function processes the input it calls the Game's
constructor with the read data as parameters.

The Writer class simply transforms all entities into a JSONObject, writes
it to a file and closes it.

The Constants class is used to store constants for output (it helped me
organize the output).

src/Main (class):
In the Main class I create a game instance by reading the input, I start
the game and I print the last game state to the output file.

Personal Notes:
I tried to make the classes as general as possible in order to help me with
the next stage, hence my implementation of Entity and Contract. The GameRules
can be simply updated to include more entities if needed.

In addition, I used a thread safe implementation for the singleton class with
little overhead (Lazy Instantiation with double checked locking principle). In
the next stage I might add an Observer.

I also tried to not break encapsulation thus I created my implementation with
as little setters and getters as possible (this is also why some methods have
the default access modifier). Moreover, I worked around the OOP principle
"Tell, Don't Ask".
